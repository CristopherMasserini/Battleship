import random


class Ship(object):
    """
    Creates a class for the ships of the battleship game

    Keeps track of the name of the ship, the length of the ship, health of the ship, the x and y coordinates
    as well as the orientation

    name (str): The name of the ship
    length (int): The length of the ship. Between 2 and 5 for ease of gaming
    health (int): The health of the ship. Initially the length of the ship
    coordinates (list of tuples): coordinates the ship is located in as: [(x1, y1), (x2, y2), ...]
    """
    def __init__(self, name, length, coordinates):
        self._name = name
        self._length = length
        self._health = length
        self.coordinates = coordinates
        self._alive = True

    # Gets if the ship is alive
    def get_alive(self) -> bool:
        return self._alive

    # A method for the ship to take damage
    # If the health drops to zero, the ship is dead
    def take_damage(self) -> bool:
        self._health -= 1
        if self._health == 0:
            self._alive = False
        return self.get_alive()


class Players(object):
    """
    Creates a class for the players of the battleship game

    Keeps track of the name of the player, as well as the number of ships that are alive and dead

    name (str): The name of the player
    """
    def __init__(self, name):
        self.name = name
        self.ships = list()  # List of ships under the control of the player
        self._alive = 0  # Number of ships that are alive
        self._dead = 0  # Number of ships that are dead

    def reset(self):
        self.ships = list()
        self._alive = 0
        self._dead = 0

    # A method to kill a ship from the players list of ships
    def kill_ship(self, ship: Ship):
        self.ships.remove(ship)
        self._alive -= 1
        self._dead += 1

    # A method to add a ship to the players list of ships
    def add_ship(self, ship: Ship):
        self.ships.append(ship)
        self._alive += 1

    # Returns the number of living and dead ships
    def get_score(self) -> tuple:
        return self._alive, self._dead


# Creates a new ship with a name and length
# Offset is used for the creation of players ship on the right hand side of the screen
# Offset should be set to zero for player on left hand side
def build_ship(name: str, length: int, offset: int) -> Ship:
    coord = list()  # Coordinates of the ship
    orient1 = random.randint(0, 1)  # 0 = horizontal or 1 = vertical
    orient2 = random.randint(0, 1)  # 0 is up/right, 1 is down/left based off of first orient
    if orient1 == 0 and orient2 == 0:  # Horizontal and right
        x = random.randint(0, 10 - length) + offset
        y = random.randint(1, 10)
        pos = (x, y)  # Position of the tip of the ship
        coord.append(pos)
        for i in range(1, length):  # Creates the coordinates for the rest of the ship based off orientation
            x += 1
            pos_next = (x, y)
            coord.append(pos_next)
    elif orient1 == 0 and orient2 == 1:  # Horizontal and left
        x = random.randint(length - 1, 9) + offset
        y = random.randint(1, 10)
        pos = (x, y)  # Position of the tip of the ship
        coord.append(pos)
        for i in range(1, length):  # Creates the coordinates for the rest of the ship based off orientation
            x -= 1
            pos_next = (x, y)
            coord.append(pos_next)
    elif orient1 == 1 and orient2 == 0:  # vertical and up. Up meaning an increase in the y, which is physically down
        x = random.randint(0, 9) + offset
        y = random.randint(1, (10 - length) + 1)
        pos = (x, y)  # Position of the tip of the ship
        coord.append(pos)
        for i in range(1, length):  # Creates the coordinates for the rest of the ship based off orientation
            y += 1
            pos_next = (x, y)
            coord.append(pos_next)
    else:  # orient1 = 1, orient2 = 1, vertical and down. Down meaning a decrease in the y, which is physically up
        x = random.randint(0, 9) + offset
        y = random.randint(length, 10)
        pos = (x, y)  # Position of the tip of the ship
        coord.append(pos)
        for i in range(1, length):  # Creates the coordinates for the rest of the ship based off orientation
            y -= 1
            pos_next = (x, y)
            coord.append(pos_next)

    print(coord)  # TODO Delete later
    return Ship(name, length, coord)


# Creates a function that will test if a ship is overlapping another for that player
# Returns true if there is an overlap, false if not
def overlap(ship_check: Ship, player: Players) -> bool:
    ship_list = player.ships
    for ship in ship_list:
        for coord in ship_check.coordinates:
            if coord in ship.coordinates:
                return True
    return False


# A function that will add a ship to a given player of given length and name.
# Offset is used for creating ships on correct side of the screen. See build_ship
def create_ship(player: Players, name: str, length_of_ship: int, offset: int):
    ship_new = build_ship(name, length_of_ship, offset)
    while True:
        if overlap(ship_new, player):
            ship_new = build_ship(name, length_of_ship, offset)
        else:
            break
    player.add_ship(ship_new)


# Checks if there is a ship at the location given by the column and row
# Returns True if hit, False if miss
def hit_check(column: int, row: int, player: Players) -> tuple:
    hit = False
    kill = False
    coord = (column, row)
    ship_list = player.ships
    for ship in ship_list:
        if coord in ship.coordinates:
            ship_alive = ship.take_damage()
            hit = True
            if not ship_alive:
                player.kill_ship(ship)
                kill = True
            return hit, kill
    return hit, kill


if __name__ == "__main__":
    pass
